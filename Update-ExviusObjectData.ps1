<#

        Object types in order of tab location:
        - Units
        - Equipment
        - Materia
        - Trust Master Reward (reverse lookup of Units probably)
        - Skills (including LBs)
        - Espers ("summons")
        - Locations (towns + dungeons)
        Object details:
        - Limit bursts are a separate file from skills, so combine
        - Going to search for towns but they only have world/region/subregion IDs. Do a lookup against that doc
        - Same as above but for dungeons
        - Espers are called "summons"

#>

# Small function to make information messages a little nicer when browsing the code.
function Write-Notice {
    param(
        [string]$Notice,
        [switch]$NoNewLine,
        [string]$Color = 'Yellow'
    )
    
    if ($NoNewLine) {
        Write-Host -Object $Notice -ForegroundColor $Color -NoNewline
    } else {
        Write-Host -Object $Notice -ForegroundColor $Color
    }
}

Write-Notice 'This script updates the formatted object data used by the search script (Find-ExviusObject.ps1).'
Write-Notice 'It will remove all data in the "Exvius<Data Type>.json" file and replace it with the existing raw data.'
Write-Notice 'If you ever modify the data generated by this script, be sure to make a backup.'
Write-Notice 'This does not modify the original raw data files.'

<# 
        Below: folder path to the raw export data of FFBE. Can be found here:
        - https://github.com/aEnigmatic/ffbe
        Special thanks to aEnigmatic.
#>
$script:RawJSONDataFolderPath = 'C:\Users\jon\OneDrive\Documents\Games\ffbe\ffbe-json-dump'
# Can replace this with an actual folder location. Otherwise it uses the script directory.
$script:JSONFolderExportPath = "$PSScriptRoot\FormattedData" 

# This clips any trailing backslashes on these variables.
$script:RawJSONDataFolderPath = $script:RawJSONDataFolderPath.TrimEnd('\')
$script:JSONFolderExportPath = $script:JSONFolderExportPath.TrimEnd('\')

Write-Notice "`nRaw game data (JSON) will be pulled from this location: " -NoNewLine -Color 'White'
Write-Notice "$RawJSONDataFolderPath`n" -Color 'Cyan'
Write-Notice "Formatted game data (JSON) will be exported to this location: " -NoNewLine -Color 'White'
Write-Notice "$JSONFolderExportPath`n`n" -Color 'Green'

Write-Notice 'Parsing and exporting all materia data...' -NoNewLine -Color 'White'

# Function to update all materia data. It will be exported to the folder defined above with $script:JSONFolderExportPath.
function Update-MateriaObjectData {
    
    BEGIN {
        # Define the FFBE object type.
        $DataType = 'materia'
        # Create a variable with the data type capitalized for naming the export file and tagging exported objects.
        # The variable above is not capitalized to match the raw data file name. This could make it easier to update later.
        $DataTypeCapitalized = $DataType.Replace($DataType[0],($DataType[0].ToString()).ToUpper())
        # Define the export file name in the format "Exvius<Data Type>.json"
        $ExportFileName = "Exvius$DataTypeCapitalized.json"
    
        # Load the raw data (exported from the FFBE APK) and convert it into a format readable by PowerShell.
        $JSONFileObjects = (Get-Content -Path "$RawJSONDataFolderPath\$DataType.json") -join "`n" | ConvertFrom-Json
    
        # The game's raw data defines each object at the topmost level by its object ID. This is different than compedium ID.
        # Gather the object IDs and store them for cycling through the data.
        $RawObjectIDs = ($JSONFileObjects | Get-Member -MemberType NoteProperty).Name
        
        # Check to see if the formatted data file already exists. If it does, remove all its content.
        $JSONFileExportPath = "$script:JSONFolderExportPath\$ExportFileName"
        if (Test-Path -Path $JSONFileExportPath -WarningAction SilentlyContinue -ErrorAction SilentlyContinue) {
            Set-Content -Path $JSONFileExportPath -Value $null
        }
        
        # Initialize an array for object data.
        $ParsedObjects = @()
        
        # Specific to materia.
        # The game uses the terms "unique" and "stackable" to refer to the same concept, but they're opposites.
        # This function swaps the two values so that, for example, unique being true means stackable is false.
        function Convert-UniqueToStackable {
            param
            (
                [string]$IsUnique
            )
            
            if ($IsUnique -eq 'true' -or $IsUnique -eq $true) {
                $Stackable = $false
            } elseif ($IsUnique -eq 'false' -or $IsUnique -eq $false) {
                $Stackable = $true
            } else {
                # Leaving the else logic in here in case data format changes in the future (e.g. unique = 'true', not unique = '')
                $Stackable = $true
            }
            
            return $Stackable
        }
    }
    
    PROCESS {
        # Cycle through each object using its object ID.
        foreach ($id in $RawObjectIDs) {
            # Define the raw data object.
            $RawObject = $JSONFileObjects.$id
            
            # Convert "unique" to "stackable" (see above).
            $Stackable = Convert-UniqueToStackable -IsUnique ($RawObject.unique).toString()
            
            # Define a new blank object and assign the object's data to it.
            # Some data is nested deeper than top level and requires different parsing.
            $ParsedObject = New-Object -TypeName PSObject
            
            $ParsedObject | Add-Member -MemberType NoteProperty -Name 'Name' -Value $RawObject.name
            $ParsedObject | Add-Member -MemberType NoteProperty -Name 'Description (Short)' -Value $RawObject.strings.desc_short[0]
            $ParsedObject | Add-Member -MemberType NoteProperty -Name 'Description (Long)' -Value $RawObject.strings.desc_long[0]
            $ParsedObject | Add-Member -MemberType NoteProperty -Name 'Stackable' -Value $Stackable
            # Deprecated: Used to be $($RawObject.effects -join ' | ')
            $ParsedObject | Add-Member -MemberType NoteProperty -Name 'Effect(s)' -Value $RawObject.effects
            # Deprecated: Used to be $($RawObject.skills -join ' | ')
            $ParsedObject | Add-Member -MemberType NoteProperty -Name 'Effect Skill ID(s)' -Value $RawObject.skills
            $ParsedObject | Add-Member -MemberType NoteProperty -Name 'Unit Restriction(s)' -Value $RawObject.unit_restriction
            $ParsedObject | Add-Member -MemberType NoteProperty -Name 'Compendium ID' -Value $RawObject.compendium_id
            $ParsedObject | Add-Member -MemberType NoteProperty -Name 'Object ID' -Value $id
            $ParsedObject | Add-Member -MemberType NoteProperty -Name 'Data Type' -Value $DataTypeCapitalized
            
            # Add the formatted object to the array of all formatted objects.
            $ParsedObjects += $ParsedObject
        }
    }
    
    END {
        # Remove unwanted symbol translations and set the encoding, then export the data.
        ($ParsedObjects | ConvertTo-Json).ForEach({[System.Text.RegularExpressions.Regex]::Unescape($_)}) |
                Out-File -FilePath $JSONFileExportPath -Encoding default -Force
    }
    
}

Update-MateriaObjectData

Write-Notice 'DONE' -Color 'Green'


<# 
    Stuff that needs to be cross-referenced:
    - Materia needs values for Unit Restrictions (unit ID -> unit name)
#>